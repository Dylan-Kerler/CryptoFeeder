{"ast":null,"code":"'use strict';\n\nconst safeBuffer = require('safe-buffer');\n\nconst Limiter = require('async-limiter');\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./BufferUtil');\n\nconst Buffer = safeBuffer.Buffer;\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\nconst kWriteInProgress = Symbol('write-in-progress');\nconst kPendingClose = Symbol('pending-close');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\nconst kOwner = Symbol('owner'); //\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\n\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */\n\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter({\n        concurrency\n      });\n    }\n  }\n  /**\n   * @type {String}\n   */\n\n\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n  /**\n   * Create extension parameters offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n\n\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n  /**\n   * Accept extension offer.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @public\n   */\n\n\n  accept(paramsList) {\n    paramsList = this.normalizeParams(paramsList);\n    var params;\n\n    if (this._isServer) {\n      params = this.acceptAsServer(paramsList);\n    } else {\n      params = this.acceptAsClient(paramsList);\n    }\n\n    this.params = params;\n    return params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n\n\n  cleanup() {\n    if (this._inflate) {\n      if (this._inflate[kWriteInProgress]) {\n        this._inflate[kPendingClose] = true;\n      } else {\n        this._inflate.close();\n\n        this._inflate = null;\n      }\n    }\n\n    if (this._deflate) {\n      if (this._deflate[kWriteInProgress]) {\n        this._deflate[kPendingClose] = true;\n      } else {\n        this._deflate.close();\n\n        this._deflate = null;\n      }\n    }\n  }\n  /**\n   * Accept extension offer from client.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsServer(paramsList) {\n    const accepted = {};\n    const result = paramsList.some(params => {\n      if (this._options.serverNoContextTakeover === false && params.server_no_context_takeover || this._options.serverMaxWindowBits === false && params.server_max_window_bits || typeof this._options.serverMaxWindowBits === 'number' && typeof params.server_max_window_bits === 'number' && this._options.serverMaxWindowBits > params.server_max_window_bits || typeof this._options.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return;\n      }\n\n      if (this._options.serverNoContextTakeover || params.server_no_context_takeover) {\n        accepted.server_no_context_takeover = true;\n      }\n\n      if (this._options.clientNoContextTakeover || this._options.clientNoContextTakeover !== false && params.client_no_context_takeover) {\n        accepted.client_no_context_takeover = true;\n      }\n\n      if (typeof this._options.serverMaxWindowBits === 'number') {\n        accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n      } else if (typeof params.server_max_window_bits === 'number') {\n        accepted.server_max_window_bits = params.server_max_window_bits;\n      }\n\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n      } else if (this._options.clientMaxWindowBits !== false && typeof params.client_max_window_bits === 'number') {\n        accepted.client_max_window_bits = params.client_max_window_bits;\n      }\n\n      return true;\n    });\n    if (!result) throw new Error(\"Doesn't support the offered configuration\");\n    return accepted;\n  }\n  /**\n   * Accept extension response from server.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsClient(paramsList) {\n    const params = paramsList[0];\n\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n\n    if (typeof this._options.clientMaxWindowBits === 'number' && (!params.client_max_window_bits || params.client_max_window_bits > this._options.clientMaxWindowBits) || this._options.clientMaxWindowBits === false && params.client_max_window_bits) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n  /**\n   * Normalize extensions parameters.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Array} Normalized extensions parameters\n   * @private\n   */\n\n\n  normalizeParams(paramsList) {\n    return paramsList.map(params => {\n      Object.keys(params).forEach(key => {\n        var value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Multiple extension parameters for ${key}`);\n        }\n\n        value = value[0];\n\n        switch (key) {\n          case 'server_no_context_takeover':\n          case 'client_no_context_takeover':\n            if (value !== true) {\n              throw new Error(`invalid extension parameter value for ${key} (${value})`);\n            }\n\n            params[key] = true;\n            break;\n\n          case 'server_max_window_bits':\n          case 'client_max_window_bits':\n            if (typeof value === 'string') {\n              value = parseInt(value, 10);\n\n              if (Number.isNaN(value) || value < zlib.Z_MIN_WINDOWBITS || value > zlib.Z_MAX_WINDOWBITS) {\n                throw new Error(`invalid extension parameter value for ${key} (${value})`);\n              }\n            }\n\n            if (!this._isServer && value === true) {\n              throw new Error(`Missing extension parameter value for ${key}`);\n            }\n\n            params[key] = value;\n            break;\n\n          default:\n            throw new Error(`Not defined extension parameter (${key})`);\n        }\n      });\n      return params;\n    });\n  }\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  decompress(data, fin, callback) {\n    zlibLimiter.push(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  compress(data, fin, callback) {\n    zlibLimiter.push(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        windowBits\n      });\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate[kOwner] = this;\n\n      this._inflate.on('error', inflateOnError);\n\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n    this._inflate[kWriteInProgress] = true;\n\n    this._inflate.write(data);\n\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`] || this._inflate[kPendingClose]) {\n        this._inflate.close();\n\n        this._inflate = null;\n      } else {\n        this._inflate[kWriteInProgress] = false;\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _compress(data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        memLevel: this._options.memLevel,\n        level: this._options.level,\n        flush: zlib.Z_SYNC_FLUSH,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = []; //\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n      // it is made after it has already been closed. This cannot happen here,\n      // so we only add a listener for the `'data'` event.\n      //\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kWriteInProgress] = true;\n\n    this._deflate.write(data);\n\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      var data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`] || this._deflate[kPendingClose]) {\n        this._deflate.close();\n\n        this._deflate = null;\n      } else {\n        this._deflate[kWriteInProgress] = false;\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n}\n\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (this[kOwner]._maxPayload < 1 || this[kTotalLength] <= this[kOwner]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new Error('max payload size exceeded');\n  this[kError].closeCode = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\n\n\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kOwner]._inflate = null;\n  this[kCallback](err);\n}","map":{"version":3,"sources":["/home/levi/Desktop/WebProjects/CryptoFeeder/frontend/dev/node_modules/binance/node_modules/ws/lib/PerMessageDeflate.js"],"names":["safeBuffer","require","Limiter","zlib","bufferUtil","Buffer","TRAILER","from","EMPTY_BLOCK","kWriteInProgress","Symbol","kPendingClose","kTotalLength","kCallback","kBuffers","kError","kOwner","zlibLimiter","PerMessageDeflate","constructor","options","isServer","maxPayload","_maxPayload","_options","_threshold","threshold","undefined","_isServer","_deflate","_inflate","params","concurrency","concurrencyLimit","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","paramsList","normalizeParams","acceptAsServer","acceptAsClient","cleanup","close","accepted","result","some","Error","map","Object","keys","forEach","key","value","length","parseInt","Number","isNaN","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","decompress","data","fin","callback","push","done","_decompress","err","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","on","inflateOnError","inflateOnData","write","flush","concat","process","nextTick","createDeflateRaw","memLevel","level","Z_SYNC_FLUSH","deflateOnData","slice","module","exports","chunk","closeCode","removeListener","reset"],"mappings":"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","sourcesContent":["'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst Limiter = require('async-limiter');\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./BufferUtil');\n\nconst Buffer = safeBuffer.Buffer;\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kWriteInProgress = Symbol('write-in-progress');\nconst kPendingClose = Symbol('pending-close');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\nconst kOwner = Symbol('owner');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor (options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined\n      ? this._options.threshold\n      : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined\n        ? this._options.concurrencyLimit\n        : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName () {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create extension parameters offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer () {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept extension offer.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept (paramsList) {\n    paramsList = this.normalizeParams(paramsList);\n\n    var params;\n    if (this._isServer) {\n      params = this.acceptAsServer(paramsList);\n    } else {\n      params = this.acceptAsClient(paramsList);\n    }\n\n    this.params = params;\n    return params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup () {\n    if (this._inflate) {\n      if (this._inflate[kWriteInProgress]) {\n        this._inflate[kPendingClose] = true;\n      } else {\n        this._inflate.close();\n        this._inflate = null;\n      }\n    }\n    if (this._deflate) {\n      if (this._deflate[kWriteInProgress]) {\n        this._deflate[kPendingClose] = true;\n      } else {\n        this._deflate.close();\n        this._deflate = null;\n      }\n    }\n  }\n\n  /**\n   * Accept extension offer from client.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer (paramsList) {\n    const accepted = {};\n    const result = paramsList.some((params) => {\n      if (\n        (this._options.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (this._options.serverMaxWindowBits === false &&\n          params.server_max_window_bits) ||\n        (typeof this._options.serverMaxWindowBits === 'number' &&\n          typeof params.server_max_window_bits === 'number' &&\n          this._options.serverMaxWindowBits > params.server_max_window_bits) ||\n        (typeof this._options.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return;\n      }\n\n      if (\n        this._options.serverNoContextTakeover ||\n        params.server_no_context_takeover\n      ) {\n        accepted.server_no_context_takeover = true;\n      }\n      if (\n        this._options.clientNoContextTakeover ||\n        (this._options.clientNoContextTakeover !== false &&\n          params.client_no_context_takeover)\n      ) {\n        accepted.client_no_context_takeover = true;\n      }\n      if (typeof this._options.serverMaxWindowBits === 'number') {\n        accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n      } else if (typeof params.server_max_window_bits === 'number') {\n        accepted.server_max_window_bits = params.server_max_window_bits;\n      }\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n      } else if (\n        this._options.clientMaxWindowBits !== false &&\n        typeof params.client_max_window_bits === 'number'\n      ) {\n        accepted.client_max_window_bits = params.client_max_window_bits;\n      }\n      return true;\n    });\n\n    if (!result) throw new Error(\"Doesn't support the offered configuration\");\n\n    return accepted;\n  }\n\n  /**\n   * Accept extension response from server.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient (paramsList) {\n    const params = paramsList[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n\n    if (\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits ||\n          params.client_max_window_bits > this._options.clientMaxWindowBits)) ||\n      (this._options.clientMaxWindowBits === false &&\n        params.client_max_window_bits)\n    ) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize extensions parameters.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Array} Normalized extensions parameters\n   * @private\n   */\n  normalizeParams (paramsList) {\n    return paramsList.map((params) => {\n      Object.keys(params).forEach((key) => {\n        var value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Multiple extension parameters for ${key}`);\n        }\n\n        value = value[0];\n\n        switch (key) {\n          case 'server_no_context_takeover':\n          case 'client_no_context_takeover':\n            if (value !== true) {\n              throw new Error(`invalid extension parameter value for ${key} (${value})`);\n            }\n            params[key] = true;\n            break;\n          case 'server_max_window_bits':\n          case 'client_max_window_bits':\n            if (typeof value === 'string') {\n              value = parseInt(value, 10);\n              if (\n                Number.isNaN(value) ||\n                value < zlib.Z_MIN_WINDOWBITS ||\n                value > zlib.Z_MAX_WINDOWBITS\n              ) {\n                throw new Error(`invalid extension parameter value for ${key} (${value})`);\n              }\n            }\n            if (!this._isServer && value === true) {\n              throw new Error(`Missing extension parameter value for ${key}`);\n            }\n            params[key] = value;\n            break;\n          default:\n            throw new Error(`Not defined extension parameter (${key})`);\n        }\n      });\n      return params;\n    });\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress (data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({ windowBits });\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate[kOwner] = this;\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n    this._inflate[kWriteInProgress] = true;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._inflate[kPendingClose]\n      ) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kWriteInProgress] = false;\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress (data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        memLevel: this._options.memLevel,\n        level: this._options.level,\n        flush: zlib.Z_SYNC_FLUSH,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n      // it is made after it has already been closed. This cannot happen here,\n      // so we only add a listener for the `'data'` event.\n      //\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kWriteInProgress] = true;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      var data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._deflate[kPendingClose]\n      ) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kWriteInProgress] = false;\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData (chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData (chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kOwner]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kOwner]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new Error('max payload size exceeded');\n  this[kError].closeCode = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError (err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kOwner]._inflate = null;\n  this[kCallback](err);\n}\n"]},"metadata":{},"sourceType":"script"}