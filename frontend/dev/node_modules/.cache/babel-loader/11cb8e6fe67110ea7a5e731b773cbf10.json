{"ast":null,"code":"'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\n\nvar id = 0;\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\n\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n  this.id = id++;\n  this.ee = ee;\n}\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\n\n\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\n\n\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n  return this;\n};\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\n\n\nUltron.prototype.remove = function remove() {\n  var args = arguments,\n      ee = this.ee,\n      event; //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    if (ee.eventNames) {\n      args = ee.eventNames();\n    } else if (ee._events) {\n      args = [];\n\n      for (event in ee._events) {\n        if (has.call(ee._events, event)) args.push(event);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        args = args.concat(Object.getOwnPropertySymbols(ee._events));\n      }\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j]; //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n      } else if (event.__ultron !== this.id) {\n        continue;\n      }\n\n      ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\n\n\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n  this.remove();\n  this.ee = null;\n  return true;\n}; //\n// Expose the module.\n//\n\n\nmodule.exports = Ultron;","map":{"version":3,"sources":["/home/levi/Desktop/WebProjects/CryptoFeeder/frontend/dev/node_modules/ultron/index.js"],"names":["has","Object","prototype","hasOwnProperty","id","Ultron","ee","on","event","fn","context","__ultron","once","remove","args","arguments","length","split","eventNames","_events","call","push","getOwnPropertySymbols","concat","i","listeners","j","listener","removeListener","destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , ee = this.ee\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    if (ee.eventNames) {\n      args = ee.eventNames();\n    } else if (ee._events) {\n      args = [];\n\n      for (event in ee._events) {\n        if (has.call(ee._events, event)) args.push(event);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        args = args.concat(Object.getOwnPropertySymbols(ee._events));\n      }\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n      } else if (event.__ultron !== this.id) {\n        continue;\n      }\n\n      ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n"]},"metadata":{},"sourceType":"script"}