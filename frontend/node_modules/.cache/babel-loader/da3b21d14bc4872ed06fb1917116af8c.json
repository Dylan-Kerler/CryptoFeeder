{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\n\nconst EventEmitter = require('events');\n\nconst crypto = require('crypto');\n\nconst Ultron = require('ultron');\n\nconst http = require('http');\n\nconst url = require('url');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\n\nconst Extensions = require('./Extensions');\n\nconst constants = require('./Constants');\n\nconst WebSocket = require('./WebSocket');\n\nconst Buffer = safeBuffer.Buffer;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n\n      this._ultron.on('listening', () => this.emit('listening'));\n\n      this._ultron.on('error', err => this.emit('error', err));\n\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, client => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  close(cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._ultron.destroy();\n\n      this._ultron = this._server = null; //\n      // Close the http server if it was internally created.\n      //\n\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n\n\n  shouldHandle(req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketError);\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !req.headers['sec-websocket-key'] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n      return abortConnection(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n      try {\n        const offers = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */); //\n    // Optionally call external protocol selection handler.\n    //\n\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    } //\n    // Optionally call external client verification handler.\n    //\n\n\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n          this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  completeUpgrade(protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + constants.GUID, 'binary').digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${key}`];\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    } //\n    // Allow external modification/inspection of handshake headers.\n    //\n\n\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n\n}\n\nmodule.exports = WebSocketServer;\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\nfunction socketError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\n\n\nfunction abortConnection(socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + `Content-Length: ${Buffer.byteLength(message)}\\r\\n` + '\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}","map":{"version":3,"sources":["/home/levi/Desktop/WebProjects/CryptoFeeder/frontend/dev/node_modules/binance/node_modules/ws/lib/WebSocketServer.js"],"names":["safeBuffer","require","EventEmitter","crypto","Ultron","http","url","PerMessageDeflate","Extensions","constants","WebSocket","Buffer","WebSocketServer","constructor","options","callback","Object","assign","maxPayload","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","listen","_ultron","on","emit","err","socket","head","handleUpgrade","client","clients","Set","close","cb","terminate","destroy","shouldHandle","parse","pathname","socketError","version","headers","extensions","method","upgrade","toLowerCase","abortConnection","offers","extensionName","accept","protocol","split","info","origin","secure","connection","authorized","encrypted","verified","code","message","completeUpgrade","readable","writable","key","createHash","update","GUID","digest","push","params","value","format","write","concat","join","protocolVersion","add","delete","removeListener","module","exports","byteLength"],"mappings":"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","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst Ultron = require('ultron');\nconst http = require('http');\nconst url = require('url');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst Extensions = require('./Extensions');\nconst constants = require('./Constants');\nconst WebSocket = require('./WebSocket');\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor (options, callback) {\n    super();\n\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n      this._ultron.on('listening', () => this.emit('listening'));\n      this._ultron.on('error', (err) => this.emit('error', err));\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, (client) => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._ultron.destroy();\n      this._ultron = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle (req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade (req, socket, head, cb) {\n    socket.on('error', socketError);\n\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortConnection(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = Extensions.parse(\n          req.headers['sec-websocket-extensions']\n        );\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\n\n    //\n    // Optionally call external protocol selection handler.\n    //\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n\n          this.completeUpgrade(\n            protocol,\n            extensions,\n            version,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade (protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const key = crypto.createHash('sha1')\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${key}`\n    ];\n\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketError () {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection (socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      `Content-Length: ${Buffer.byteLength(message)}\\r\\n` +\n      '\\r\\n' +\n      message\n    );\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}\n"]},"metadata":{},"sourceType":"script"}