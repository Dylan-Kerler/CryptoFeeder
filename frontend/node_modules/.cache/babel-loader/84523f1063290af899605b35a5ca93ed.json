{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\n\nconst isValidUTF8 = require('./Validation');\n\nconst bufferUtil = require('./BufferUtil');\n\nconst ErrorCodes = require('./ErrorCodes');\n\nconst constants = require('./Constants');\n\nconst Buffer = safeBuffer.Buffer;\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n */\n\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor(extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n    this._state = GET_INFO;\n  }\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n\n\n  readBuffer(bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n    this._bufferedBytes -= bytes;\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n\n    dst = Buffer.allocUnsafe(bytes);\n\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n\n        offset += l;\n\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n\n      bytes -= l;\n    }\n\n    return dst;\n  }\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n\n\n  hasBufferedBytes(n) {\n    if (this._bufferedBytes >= n) return true;\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n\n\n  add(data) {\n    if (this._dead) return;\n    this._bufferedBytes += data.length;\n\n    this._buffers.push(data);\n\n    this.startLoop();\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n\n\n  startLoop() {\n    this._loop = true;\n\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n\n        case GET_MASK:\n          this.getMask();\n          break;\n\n        case GET_DATA:\n          this.getData();\n          break;\n\n        default:\n          // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n\n\n  getInfo() {\n    if (!this.hasBufferedBytes(2)) return;\n    const buf = this.readBuffer(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n\n\n  getPayloadLength16() {\n    if (!this.hasBufferedBytes(2)) return;\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n\n\n  getPayloadLength64() {\n    if (!this.hasBufferedBytes(8)) return;\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true); //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n\n\n  haveLength() {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n\n\n  getMask() {\n    if (!this.hasBufferedBytes(4)) return;\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n\n\n  getData() {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n\n\n  decompress(data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n\n\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onmessage(buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n\n\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.onping(data);else this.onpong(data);\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n\n\n  error(err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n\n\n  maxPayloadExceeded(length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n    const fullLength = this._totalPayloadLength + length;\n\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n\n\n  pushFragment(fragment) {\n    if (fragment.length === 0) return true;\n    const totalLength = this._messageLength + fragment.length;\n\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n\n      this._fragments.push(fragment);\n\n      return true;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  cleanup(cb) {\n    this._dead = true;\n\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n      if (cb) cb();\n    }\n  }\n\n}\n\nmodule.exports = Receiver;\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\n\nfunction toBuffer(fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}","map":{"version":3,"sources":["/home/levi/Desktop/WebProjects/CryptoFeeder/frontend/dev/node_modules/binance/node_modules/ws/lib/Receiver.js"],"names":["safeBuffer","require","PerMessageDeflate","isValidUTF8","bufferUtil","ErrorCodes","constants","Buffer","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver","constructor","extensions","maxPayload","binaryType","_binaryType","BINARY_TYPES","_extensions","_maxPayload","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_mask","_opcode","_totalPayloadLength","_messageLength","_fragments","_cleanupCallback","_hadError","_dead","_loop","onmessage","onclose","onerror","onping","onpong","_state","readBuffer","bytes","offset","dst","l","length","shift","slice","allocUnsafe","copy","hasBufferedBytes","n","cleanup","add","data","push","startLoop","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","buf","error","Error","compressed","extensionName","haveLength","readUInt16BE","num","readUInt32BE","Math","pow","maxPayloadExceeded","EMPTY_BUFFER","unmask","controlMessage","decompress","pushFragment","dataMessage","perMessageDeflate","err","closeCode","messageLength","fragments","toBuffer","toArrayBuffer","toString","code","isValidErrorCode","fullLength","fragment","totalLength","cb","module","exports","concat","byteOffset","byteLength","buffer"],"mappings":"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","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst isValidUTF8 = require('./Validation');\nconst bufferUtil = require('./BufferUtil');\nconst ErrorCodes = require('./ErrorCodes');\nconst constants = require('./Constants');\n\nconst Buffer = safeBuffer.Buffer;\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n */\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor (extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n  readBuffer (bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n\n    this._bufferedBytes -= bytes;\n\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n\n    dst = Buffer.allocUnsafe(bytes);\n\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n        offset += l;\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n\n      bytes -= l;\n    }\n\n    return dst;\n  }\n\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n  hasBufferedBytes (n) {\n    if (this._bufferedBytes >= n) return true;\n\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n  add (data) {\n    if (this._dead) return;\n\n    this._bufferedBytes += data.length;\n    this._buffers.push(data);\n    this.startLoop();\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n  startLoop () {\n    this._loop = true;\n\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData();\n          break;\n        default: // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n  getInfo () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    const buf = this.readBuffer(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n  getPayloadLength16 () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n  getPayloadLength64 () {\n    if (!this.hasBufferedBytes(8)) return;\n\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n\n    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n  haveLength () {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask () {\n    if (!this.hasBufferedBytes(4)) return;\n\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n  getData () {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n  decompress (data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n  dataMessage () {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onmessage(buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n  controlMessage (data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.onping(data);\n    else this.onpong(data);\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n  error (err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n  maxPayloadExceeded (length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n\n    const fullLength = this._totalPayloadLength + length;\n\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n  pushFragment (fragment) {\n    if (fragment.length === 0) return true;\n\n    const totalLength = this._messageLength + fragment.length;\n\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n      this._fragments.push(fragment);\n      return true;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  cleanup (cb) {\n    this._dead = true;\n\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n\n      if (cb) cb();\n    }\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\nfunction toBuffer (fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\nfunction toArrayBuffer (buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n"]},"metadata":{},"sourceType":"script"}